.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PERLIMPORTS 1p"
.TH PERLIMPORTS 1p 2025-10-30 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH SYNOPSIS
.IX Header "SYNOPSIS"
Create a config file called \f(CW\*(C`perlimports.toml\*(C'\fR at the top level of your
application or repository:
.PP
.Vb 1
\&    perlimports \-\-create\-config\-file perlimports.toml
.Ve
.PP
You can also have a config file with a leading \f(CW\*(C`.\*(C'\fR.
.PP
.Vb 1
\&    perlimports \-\-create\-config\-file .perlimports.toml
.Ve
.PP
For system-wide defaults, you can create a file in \f(CW$XDG_HOME\fR. Something like:
.PP
.Vb 1
\&    perlimports \-\-create\-config\-file ~/.config/perlimports/perlimports.toml
.Ve
.PP
After you have set up the config file to your liking, you can do away with most
command line switches, other than \f(CW\*(C`\-i\*(C'\fR, \f(CW\*(C`\-\-lint\*(C'\fR or \f(CW\*(C`\-\-read\-stdin\*(C'\fR.
.PP
Now, let's update a file in place. (Make sure you can revert the file if you
need to, as \f(CW\*(C`perlimports\*(C'\fR will not make a backup.)
.PP
.Vb 1
\&    perlimports \-i foo.pl
.Ve
.PP
Lint a file:
.PP
.Vb 1
\&    perlimports \-\-lint foo.pl
.Ve
.PP
In-place edits on directories:
.PP
.Vb 1
\&    perlimports \-i lib t xt
.Ve
.PP
Lint directories:
.PP
.Vb 1
\&    perlimports \-\-lint lib t xt
.Ve
.PP
In-place edits on files and directories
.PP
.Vb 1
\&    perlimports \-i foo.pl lib t xt
.Ve
.PP
Run \f(CW\*(C`perlimports\*(C'\fR on a file and only print the results to STDOUT.
.PP
.Vb 1
\&    perlimports foo.pl
.Ve
.PP
If some of your imported modules are in local directories, you can give some
hints as to where to find them:
.PP
.Vb 1
\&    perlimports \-i \-\-libs t/lib,/some/dir/lib foo.pl
.Ve
.PP
Redirect output to a new file:
.PP
.Vb 1
\&    perlimports foo.pl > foo.new.pl
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This distribution provides the \f(CW\*(C`perlimports\*(C'\fR command line interface (CLI),
which automates the cleanup and maintenance of Perl \f(CW\*(C`use\*(C'\fR and \f(CW\*(C`require\*(C'\fR
statements. Loosely inspired by
goimports <https://pkg.go.dev/golang.org/x/tools/cmd/goimports>, this tool
aims to be part of your linting and tidying workflow, in much the same way you
might use perltidy or perlcritic.
.PP
For a detailed discussion of the problems this tool attempts to solve, see
this "Conference in the Cloud" talk from June 2021:
Where did that Symbol Come From? <https://www.youtube.com/watch?v=fKqxdTbGxYY>.
.PP
Slides for the above talk are also available:
.PP
.Vb 1
\&     curl \-O https://raw.githubusercontent.com/oalders/presentations/main/slides/6\-perlimports/remark.html && open remark.html
.Ve
.SH MOTIVATION
.IX Header "MOTIVATION"
Many Perl modules helpfully export functions and variables by default. These
provide handy shortcuts when you're writing a quick or small script, but they
can quickly become a maintenance burden as code grows organically. When code
increases in complexity, it leads to greater costs in terms of development time.
Conversely, reducing code complexity can speed up development. This tool aims
to reduce complexity to further this goal.
.PP
While importing symbols by default or using export tags provides a convenient
shorthand for getting work done, this shorthand requires the developer to
retain knowledge of these defaults and tags in order to understand the code.
\&\f(CW\*(C`perlimports\*(C'\fR aims to allow you to develop your code as you see fit, while
still giving you a viable option of tidying your imports automatically. In much
the same way as you might use perltidy to format your code, you can now
automate the process of making your imports easier to understand. Let's look at
some examples.
.IP "Where is this function defined?" 4
.IX Item "Where is this function defined?"
You may come across some code like this:
.Sp
.Vb 2
\&    use strict;
\&    use warnings;
\&
\&    use HTTP::Request::Common;
\&    use LWP::UserAgent;
\&
\&    my $ua = LWP::UserAgent\->new;
\&    my $req = $ua\->request( GET \*(Aqhttps://metacpan.org/\*(Aq );
\&    print $req\->content;
.Ve
.Sp
Where does \f(CW\*(C`GET\*(C'\fR come from? If you're not familiar with
HTTP::Request::Common, you may not realize that the statement \f(CW\*(C`use
HTTP::Request::Common\*(C'\fR has implicitly imported the functions \f(CW\*(C`GET\*(C'\fR, \f(CW\*(C`HEAD\*(C'\fR,
\&\f(CW\*(C`PUT\*(C'\fR, \f(CW\*(C`PATCH\*(C'\fR, \f(CW\*(C`POST\*(C'\fR and \f(CW\*(C`OPTIONS\*(C'\fR into to this block of code.
.Sp
What would happen if we used \f(CW\*(C`perlimports\*(C'\fR to import all needed functions
explicitly? It might look something like this:
.Sp
.Vb 2
\&    use strict;
\&    use warnings;
\&
\&    use HTTP::Request::Common qw( GET );
\&    use LWP::UserAgent ();
\&
\&    my $ua = LWP::UserAgent\->new;
\&    my $req = $ua\->request( GET \*(Aqhttps://metacpan.org/\*(Aq );
\&    print $req\->content;
.Ve
.Sp
The code above makes it immediately obvious where \f(CW\*(C`GET\*(C'\fR originates, which in
turn makes it easier for us to look up its documentation. It has the added
bonus of also not importing \f(CW\*(C`HEAD\*(C'\fR, \f(CW\*(C`PUT\*(C'\fR or any of the other functions which
HTTP::Request::Common exports by default. So, those functions cannot
unwittingly be used later in the code. This makes for more understandable code
for present day you, future you and any others tasked with reading your code at
some future point.
.Sp
Keep in mind that this simple act can save much time for developers who are not
intimately familiar with Perl and the default exports of many CPAN modules.
.IP "Are we even using all of these imports?" 4
.IX Item "Are we even using all of these imports?"
Imagine the following import statement
.Sp
.Vb 10
\&    use HTTP::Status qw(
\&        is_cacheable_by_default
\&        is_client_error
\&        is_error
\&        is_info
\&        is_redirect
\&        is_server_error
\&        is_success
\&        status_message
\&    );
.Ve
.Sp
followed by 3,000 lines of code. How do you know if all of these functions are
actually being used? Were they ever used? You can grep all of these function
names manually or you can remove them by trial and error to see what breaks.
This is a doable solution, but it does not scale well to scripts and modules
with many imports or to large code bases with many imports. Having an
unmaintained list of imports is preferable to implicit imports, but it would be
helpful to automate maintaining this list.
.Sp
perlimports can, in many situations, clean up your import statements and
automate this maintenance burden away. This makes it easier for you to write
clean code, which is easier to understand.
.IP "Are we even using all of these modules?" 4
.IX Item "Are we even using all of these modules?"
In cases where code is implicitly importing from modules or where explicit
imports are not being curated, it can be hard to discover which modules are no
longer being used in a script, module or even a code base. Removing unused
modules from code can lead to gains in performance and decrease in consumption
of resources. Removing entire modules from your code base can decrease the
number of dependencies which you need to manage and decrease friction in your
your deployment process.
.Sp
\&\f(CW\*(C`perlimports\*(C'\fR can remove unused modules for you, making dependency management
much easier.
.IP "Enforcing a consistent style" 4
.IX Item "Enforcing a consistent style"
Having a messy list of module imports makes your code harder to read. Imagine
this:
.Sp
.Vb 6
\&    use Cpanel::JSON::XS;
\&    use Database::Migrator::Types qw( HashRef ArrayRef Object Str Bool Maybe CodeRef FileHandle RegexpRef );
\&    use List::AllUtils qw( uniq any );
\&    use LWP::UserAgent    q{};
\&    use Try::Tiny qw/ catch     try /;
\&    use WWW::Mechanize  q<>;
.Ve
.Sp
perlimports turns the above list into:
.Sp
.Vb 10
\&    use Cpanel::JSON::XS ();
\&    use Database::Migrator::Types qw(
\&        ArrayRef
\&        Bool
\&        CodeRef
\&        FileHandle
\&        HashRef
\&        Maybe
\&        Object
\&        RegexpRef
\&        Str
\&    );
\&    use List::AllUtils qw( any uniq );
\&    use LWP::UserAgent ();
\&    use Try::Tiny qw( catch try);
\&    use WWW::Mechanize ();
.Ve
.Sp
Where possible, perlimports will enforce a consistent style of parentheses
and will also sort your imports and break up long lines. As mentioned above, if
some imports are no longer in use, \f(CW\*(C`perlimports\*(C'\fR will helpfully remove these
for you.
.IP "Import tags" 4
.IX Item "Import tags"
Import tags may obscure where symbols are coming from. While import tags
provide a useful shorthand, they can contribute to code complexity by obscuring
the origin of imported symbols. Consider:
.Sp
.Vb 1
\&    use HTTP::Status qw(:constants :is status_message);
.Ve
.Sp
The above line imports the \f(CWstatus_message()\fR function as well *some other
things* via \f(CW\*(C`:constants\*(C'\fR and \f(CW\*(C`:is\*(C'\fR. What exactly are these things? We'll need
to read the documentation to know for sure.
.Sp
\&\f(CW\*(C`perlimports\*(C'\fR can audit your code and expand the line above to list the
symbols which you are actually importing. So, the line above might now look
something like:
.Sp
.Vb 10
\&    use HTTP::Status qw(
\&        HTTP_ACCEPTED
\&        HTTP_BAD_REQUEST
\&        HTTP_CONTINUE
\&        HTTP_I_AM_A_TEAPOT
\&        HTTP_MOVED_PERMANENTLY
\&        HTTP_NO_CODE
\&        HTTP_NOT_FOUND
\&        HTTP_OK
\&        HTTP_PAYLOAD_TOO_LARGE
\&        HTTP_PERMANENT_REDIRECT
\&        HTTP_RANGE_NOT_SATISFIABLE
\&        HTTP_REQUEST_ENTITY_TOO_LARGE
\&        HTTP_REQUEST_RANGE_NOT_SATISFIABLE
\&        HTTP_REQUEST_URI_TOO_LARGE
\&        HTTP_TOO_EARLY
\&        HTTP_UNORDERED_COLLECTION
\&        HTTP_URI_TOO_LONG
\&        is_cacheable_by_default
\&        is_client_error
\&        is_error
\&        is_info
\&        is_redirect
\&        is_server_error
\&        is_success
\&        status_message
\&    );
.Ve
.Sp
This is more verbose, but grepping your code will now reveal to you where
something like \f(CW\*(C`is_cacheable_by_default\*(C'\fR gets defined. You have increased the
lines of code, but you have also reduced complexity.
.SH "COMMAND LINE PARAMETERS"
.IX Header "COMMAND LINE PARAMETERS"
.SS \-\-create\-config\-file
.IX Subsection "--create-config-file"
Expects a path to a \f(CW\*(C`.toml\*(C'\fR file which does not yet exist.
.PP
.Vb 2
\&    \-\-create\-config\-file perlimports.toml
\&    \-\-create\-config\-file .perlimports.toml
.Ve
.PP
For system-wide defaults, you can create a file in \f(CW$XDG_HOME\fR. Something like:
.PP
.Vb 1
\&    perlimports \-\-create\-config\-file ~/.config/perlimports/perlimports.toml
.Ve
.PP
All of the above are default file locations which perlimports will search,
unless \f(CW\*(C`\-\-config\-file\*(C'\fR has been provided as an argument.
.SS \-\-config\-file
.IX Subsection "--config-file"
Path to a perlimports config file. If this parameter is not supplied, we will
look for a file called \f(CW\*(C`perlimports.toml\*(C'\fR or \f(CW\*(C`.perlimports.toml\*(C'\fR in the
current directory and then look for a perlimports.toml in XDG_CONFIG_HOME
(usually something like \f(CW\*(C`$HOME/perlimports/perlimports.toml\*(C'\fR). This behaviour
can be disabled via \f(CW\*(C`\-\-no\-config\-file\*(C'\fR as described below.
.SS \-\-no\-config\-file
.IX Subsection "--no-config-file"
Prevents perlimports from automatically using a config file which is in one
of the standard locations. Use this option if you want to define all of your behaviours on the command line.
.SS \-\-filename|\-f
.IX Subsection "--filename|-f"
The absolute or relative path to a file (or directory) to process.
.PP
.Vb 1
\&    \-\-filename path/to/file
\&
\&    \-f path/to/file
\&
\&    \-f path/to/dir
.Ve
.PP
Note that if you do not provide a \f(CW\*(C`\-\-filename\*(C'\fR we will fall back to checking
\&\f(CW@ARGV\fR for any remaining args. So,
.PP
.Vb 1
\&    perlimports \-\-filename path/to/file
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&    perlimports path/to/file
.Ve
.PP
You may also pass multiple file and dir names.
.PP
.Vb 1
\&    perlimports path/to/file path/to/other/file lib t xt
.Ve
.SS \-\-ignore\-modules
.IX Subsection "--ignore-modules"
A comma-separated list of module names which should be ignored by this script.
Any modules in this list should remain unchanged after processing.
.PP
.Vb 1
\&    \-\-ignore\-modules Foo,Foo::Bar
.Ve
.SS \-\-ignore\-modules\-filename
.IX Subsection "--ignore-modules-filename"
The absolute or relative path to a file which contains a lost of module names
to ignore. (See above for behaviour). The pattern is one module name per line.
.PP
.Vb 2
\&    Foo
\&    Foo::Bar
.Ve
.SS \-\-ignore\-modules\-pattern
.IX Subsection "--ignore-modules-pattern"
A regular expression to match module names which should be ignored by this
script. Any modules matched by this regular expression remain unchanged after
processing.
.PP
.Vb 1
\&    \-\-ignore\-modules\-pattern \*(Aq^(Foo|Foo::Bar)\*(Aq
.Ve
.SS \-\-ignore\-modules\-pattern\-filename
.IX Subsection "--ignore-modules-pattern-filename"
The absolute or relative path to a file which contains a list of regular
expression that matches modules that should be ignored. (See above for behaviour).
The pattern is one regular expression per line.
.PP
.Vb 2
\&    ^Foo
\&    ^Foo::Bar
.Ve
.SS \-\-never\-export\-modules
.IX Subsection "--never-export-modules"
A comma-separated list of module names which should never export symbols. If
these modules are found, we will ensure that they have an empty import list.
So, \f(CW\*(C`use Foo;\*(C'\fR becomes \f(CW\*(C`use Foo ();\*(C'\fR.
.PP
.Vb 1
\&    \-\-never\-export\-modules Foo,Foo::Bar
.Ve
.SS \-\-never\-export\-modules\-filename
.IX Subsection "--never-export-modules-filename"
The absolute or relative path to a file which contains a lost of module names
which should never export symbols. (See above for behaviour). The pattern is
one module name per line.
.PP
.Vb 2
\&    Foo
\&    Foo::Bar
.Ve
.SS \-\-inplace\-edit|\-i
.IX Subsection "--inplace-edit|-i"
Edit the file in place rather than printing the result to STDOUT. Make sure you
have a backup copy first.
.PP
.Vb 2
\&    \-\-inplace\-\-edit
\&    \-i
.Ve
.PP
Edit the file in place rather than printing the result to STDOUT. Make sure you
have a backup copy first.
.SS \-\-json
.IX Subsection "--json"
(Experimental). If enabled, linting errors will be emitted as JSON objects with
one object per error. This is intended to make it easier for editors to parse
line numbers and column numbers as well as the error message. This flag can
only be used in tandem with \f(CW\*(C`\-\-lint\*(C'\fR.
.SS \-\-lint
.IX Subsection "--lint"
If this argument is passed, \f(CW\*(C`perlimports\*(C'\fR will act as a linter, rather than a
tidier. Failure (and success) messages will be reported on STDERR. Failures
will also return a non-zero exit code.
.PP
This is still a bit experimental, so the output format and exit codes could
change in a subsequent release.
.PP
This cannot be combined with tidying. So, passing \f(CW\*(C`\-\-lint \-\-inplace\-edit\*(C'\fR will
generate an error.
.SS \-\-[no\-]padding
.IX Subsection "--[no-]padding"
\&\f(CW\*(C`\-\-padding\*(C'\fR is enabled by default, so you only need to pass this arg if you
want to be explicit. This setting adds whitespace inside the parentheses.
.PP
.Vb 2
\&    # \-\-padding
\&    use Foo qw( bar baz );
.Ve
.PP
The \f(CW\*(C`\-\-no\-padding\*(C'\fR arg allows you to disable the additional padding inside
parentheses.
.PP
.Vb 2
\&    # \-\-no\-padding
\&    use Foo qw(bar baz);
.Ve
.SS \-\-[no\-]tidy\-whitespace
.IX Subsection "--[no-]tidy-whitespace"
\&\f(CW\*(C`\-\-tidy\-whitespace\*(C'\fR is enabled by default. This means that use statements will
be updated even when the only change is in whitespace. Disabling this can help
reduce the churn involved when running \f(CW\*(C`perlimports\*(C'\fR, especially if the codebase
does not have automated tidying.
.PP
If you have changed from \f(CW\*(C`\-\-padding\*(C'\fR to \f(CW\*(C`\-\-no\-padding\*(C'\fR or vice versa, you'll
probably want to ensure that \f(CW\*(C`\-\-tidy\-whitespace\*(C'\fR has also been enabled so that
you can see the whitespace changes.
.SS \-\-libs
.IX Subsection "--libs"
A comma separated list of module directories which are not in your \f(CW@INC\fR
.PP
.Vb 1
\&    \-\-libs lib,t/lib
.Ve
.SS \-\-[no\-]preserve\-duplicates
.IX Subsection "--[no-]preserve-duplicates"
When enabled, only one use statement per module will be preserved. Defaults to
preserving duplicate statements.
.PP
For example, when enabled the following text
.PP
.Vb 2
\&    use Foo qw( bar );
\&    use Foo qw (baz );
.Ve
.PP
will be converted to:
.PP
.Vb 1
\&    use Foo qw( bar baz );
.Ve
.PP
If left disabled, the above will probably be converted to:
.PP
.Vb 2
\&    use Foo qw( bar baz );
\&    use Foo qw( bar baz );
.Ve
.PP
This allows you to determine manually how you'd like to handle the imports in
question. Use this setting with care.
.SS \-\-[no\-]preserve\-unused
.IX Subsection "--[no-]preserve-unused"
When enabled, unused modules will be removed. Defaults to preserving unused
modules.
.PP
Enabling this may remove modules which are only present for the purposes of
preloading or which aren't being detected for other reasons, so use this
setting with care.
.SS \-\-range\-begin
.IX Subsection "--range-begin"
Experimental. First line of a range to tidy or lint. The line ranges begin at 1
(not 0). This will select the appropriate range of lines from \f(CW\*(C`STDIN\*(C'\fR.
Requires \f(CW\*(C`\-\-read\-stdin\*(C'\fR. Mostly useful for editors. Unless you're writing an
editor plugin or extension, you can probably ignore this.
.SS \-\-range\-end
.IX Subsection "--range-end"
Experimental. Last line of a range to tidy or lint. The line ranges begin at 1
(not 0). This will select the appropriate range of lines from \f(CW\*(C`STDIN\*(C'\fR.
Requires \f(CW\*(C`\-\-read\-stdin\*(C'\fR. Mostly useful for editors. Unless you're writing an
editor plugin or extension, you can probably ignore this.
.SS \-\-read\-stdin
.IX Subsection "--read-stdin"
Read statements to process from STDIN rather than processing the entire file.
This is intended for use by editors, like \f(CW\*(C`vim\*(C'\fR. See the
"INTEGRATIONS" section below
for more information on how to set up an integration with your editor.
.PP
If this option is enabled, then \f(CW\*(C`\-\-inplace\-edit|\-i\*(C'\fR is not available.
.PP
.Vb 1
\&    \-\-read\-stdin
.Ve
.SS \-\-log\-level|\-l
.IX Subsection "--log-level|-l"
Generally only useful for debugging. \f(CW\*(C`notice\*(C'\fR notifies about progress, like
which file or snippet is currently being processed. \f(CW\*(C`info\*(C'\fR will generally log
the errors which were swallowed as text was being processed. All levels are
subject to change.
.PP
.Vb 4
\&    \-\-log\-level notice
\&    \-\-log\-level info
\&    \-l notice
\&    \-l info
.Ve
.PP
See <https://metacpan.org/pod/Log::Dispatch#LOG\-LEVELS> for a list of
available log levels. Log output defaults to STDERR. See \f(CW\*(C`\-\-log\-filename\*(C'\fR if
you'd rather log to a file.
.SS \-\-log\-filename
.IX Subsection "--log-filename"
Name of a file to redirect logs to, rather than STDERR.
.SS \-\-help
.IX Subsection "--help"
Output a concise help menu, with a summary of available parameters.
.PP
.Vb 1
\&    \-\-help
.Ve
.SS \-\-verbose\-help
.IX Subsection "--verbose-help"
Include the SYNOPSIS section from this page after printing the \f(CW\*(C`\-\-help\*(C'\fR menu
listed above.
.SH "ANNOTATIONS/IGNORING MODULES"
.IX Header "ANNOTATIONS/IGNORING MODULES"
Aside from the documented command line switches for ignoring modules, you can
add annotations in your code.
.PP
.Vb 1
\&    use Encode; ## no perlimports
.Ve
.PP
The above will tell perlimports not to attempt a tidy of this line.
.PP
.Vb 4
\&    ## no perlimports
\&    use Encode;
\&    use Cpanel::JSON::XS;
\&    ## use perlimports
\&
\&    use POSIX ();
.Ve
.PP
The above will tell perlimports not to tidy the two modules contained inside
of the annotations.
.PP
Please note that since perlimports needs to know as much as possible about
what's going on in a file, the annotations don't prevent modules from being
loaded. It's only a directive to leave the lines in the file unchanged after
processing.
.SH INTEGRATIONS
.IX Header "INTEGRATIONS"
You are encouraged to make this tool part of your automated tidying workflow.
Some guidance on how to configure this follows.
.SS VIM
.IX Subsection "VIM"
If you're a \f(CW\*(C`vim\*(C'\fR user, you can pipe your import statements to perlimports directly.
.PP
.Vb 1
\&    :vnoremap <silent> im :!perlimports \-\-read\-stdin \-\-filename \*(Aq%:p\*(Aq<CR>
.Ve
.PP
The above statement will allow you to visually select one or more lines of code
and have them updated in place by \f(CW\*(C`perlimports\*(C'\fR. Once you have selected the
code enter \f(CW\*(C`im\*(C'\fR to have your imports (re)formatted.
.SS "VIM and ALE"
.IX Subsection "VIM and ALE"
If you use ALE with vim, you can add something like this to your \f(CW\*(C`vim\*(C'\fR
configuration. Note that this function will save your buffer before running
\&\f(CW\*(C`perlimports\*(C'\fR.
.PP
.Vb 6
\&    function! Perlimports(buffer) abort
\&      write
\&      return {
\&      \e   \*(Aqcommand\*(Aq: \*(Aqperlimports \-\-read\-stdin \-f %s\*(Aq
\&      \e}
\&    endfunction
\&
\&    let ale_fixers.perl = [\*(Aqperlimports\*(Aq, \*(Aqperltidy\*(Aq]
\&    execute ale#fix#registry#Add(\*(Aqperlimports\*(Aq, \*(AqPerlimports\*(Aq, [\*(Aqperl\*(Aq], \*(AqTidy Perl imports\*(Aq)
.Ve
.SS "Emacs and Flycheck"
.IX Subsection "Emacs and Flycheck"
Flycheck <https://www.flycheck.org/> 35 and newer will suggest changes
from \f(CW\*(C`perlimports\*(C'\fR automatically if it finds that it is installed.
.SS precious
.IX Subsection "precious"
If you're a <https://github.com/houseabsolute/precious> user, your
configuration might look something like this:
.PP
.Vb 10
\&    exclude = [
\&        # Used by Dist::Zilla
\&        ".build",
\&        "App\-perlimports\-*",
\&        "blib",
\&        "inc",
\&        "test\-data",
\&        # All of these are generated by Dist::Zilla
\&        "t/00\-*",
\&        "t/author\-*",
\&        "t/release\-*",
\&        "xt/author",
\&        "xt/release",
\&    ]
\&
\&    [commands.perlimports]
\&    type = "both"
\&    include = [ "**/*.{pl,pm,t,psgi}" ]
\&    cmd = [ "perlimports" ]
\&    lint_flags = [ "\-\-lint"]
\&    tidy_flags = [ "\-i"]
\&    ok_exit_codes = 0
\&    expect_stderr = true
\&
\&    [commands.perltidy]
\&    type = "both"
\&    include = [ "**/*.{pl,pm,t,psgi}" ]
\&    cmd = [ "perltidy", "\-\-profile=$PRECIOUS_ROOT/perltidyrc" ]
\&    lint_flags = [ "\-\-assert\-tidy", "\-\-no\-standard\-output", "\-\-outfile=/dev/null" ]
\&    tidy_flags = [ "\-\-backup\-and\-modify\-in\-place", "\-\-backup\-file\-extension=/" ]
\&    ok_exit_codes = 0
\&    lint_failure_exit_codes = 2
\&    expect_stderr = true
.Ve
.PP
Note that <https://github.com/houseabsolute/precious> runs plugins in order,
so we've placed a perltidy config after perlimports. This is handy
because perlimports could introduce changes which will later be reverted by
perltidy. By running them sequentially we can avoid false positives which
might be generated by perlimports changing an include which perltidy
might revert.
.PP
For an up to date example, see the config file which this repository uses:
<https://github.com/oalders/App\-perlimports/blob/main/precious.toml>
.SS Code::TidyAll
.IX Subsection "Code::TidyAll"
If you're a Code::TidyAll user, you can configure \f(CW\*(C`perlimports\*(C'\fR as a
GenericTransformer. Your configuration might look something like this:
.PP
.Vb 10
\&    [GenericTransformer perlimports]
\&    select = **/*.{pl,pm,t,psgi}
\&    ignore = .build/**/*
\&    ignore = App\-perlimports\-*/**/*
\&    ignore = blib/**/*
\&    ignore = fatlib/**/*
\&    ignore = inc/**/*
\&    ignore = t/00\-*
\&    ignore = t/author\-*
\&    ignore = t/release\-*
\&    ignore = t/zzz\-*
\&    ignore = test\-data/**/*
\&    ignore = xt/**/*
\&    ignore = xt/author/{pod\-coverage,pod\-spell,tidyall}.t
\&    argv = \-\-libs lib,t/lib \-\-no\-preserve\-duplicates \-\-no\-preserve\-unused \-\-log\-filename /tmp/perlimports.txt \-\-log\-level debug
\&    cmd = perlimports
\&    file_flag = \-f
\&    ok_exit_codes = 0
\&    weight = 1
.Ve
.PP
Note that in this case we've set the lowest possible weight. This is because we
want \f(CW\*(C`perlimports\*(C'\fR to run before any other plugin which may transform the
file. For example, you'll want perltidy to run after \f(CW\*(C`perlimports\*(C'\fR to avoid
having to re-tidy files after your use statements have been rewritten.
.PP
If you want to use \f(CW\*(C`tidyall\*(C'\fR to run just \f(CW\*(C`perlimports\*(C'\fR you'll need to do
something like:
.PP
.Vb 1
\&    tidyall \-\-plugin "GenericTransformer perlimports" \-a
.Ve
.PP
For an up to date example, see the config file which this repository uses:
<https://github.com/oalders/App\-perlimports/blob/main/tidyall.ini>
.SH RECIPES
.IX Header "RECIPES"
Included are some examples to use if you want to employ your own file finding
logic or prefer not to use config files. If this does not apply to you, you can
safely skip this section.
.PP
Running perlimports on test files
.PP
.Vb 9
\&    find t \-type f |              \e
\&      grep .t$ |                  \e
\&      xargs perlimports           \e
\&      \-\-libs lib,t/lib            \e
\&      \-\-ignore\-modules Test::More \e
\&      \-\-no\-preserve\-unused        \e
\&      \-\-no\-preserve\-duplicates    \e
\&      \-\-log\-level debug           \e
\&      \-i
.Ve
.PP
The above command:
.IP \(bu 4
finds all test files in \f(CW\*(C`./t\*(C'\fR
.IP \(bu 4
pipes them to \f(CW\*(C`perlimports\*(C'\fR
.IP \(bu 4
adds \f(CW\*(C`lib\*(C'\fR and \f(CW\*(C`t/lib\*(C'\fR to \f(CW@INC\fR
.IP \(bu 4
ignores the Test::More module
.IP \(bu 4
removes unused modules
.IP \(bu 4
removes duplicated use statements
.IP \(bu 4
displays debugging info
.IP \(bu 4
edits files in place (\f(CW\*(C`\-i\*(C'\fR)
.PP
Users of ack can make this a touch simpler:
.PP
.Vb 8
\&      ack \-f \-\-perltest           \e
\&      xargs perlimports           \e
\&      \-\-libs lib,t/lib            \e
\&      \-\-ignore\-modules Test::More \e
\&      \-\-no\-preserve\-unused        \e
\&      \-\-no\-preserve\-duplicates    \e
\&      \-\-log\-level debug           \e
\&      \-i
.Ve
.PP
Running perlimports on modules:
.PP
.Vb 7
\&    find lib \-type f |         \e
\&      grep .pm$ |              \e
\&      xargs perlimports        \e
\&      \-\-libs lib               \e
\&      \-\-no\-preserve\-unused     \e
\&      \-\-no\-preserve\-duplicates \e
\&      \-i
.Ve
.PP
The above command:
.IP \(bu 4
finds all .pm files in \f(CW\*(C`./lib\*(C'\fR
.IP \(bu 4
pipes them to \f(CW\*(C`perlimports\*(C'\fR
.IP \(bu 4
adds \f(CW\*(C`lib\*(C'\fR to \f(CW@INC\fR
.IP \(bu 4
removes unused modules
.IP \(bu 4
removes duplicated use statements
.IP \(bu 4
edits files in place (\f(CW\*(C`\-i\*(C'\fR)
.PP
We can also make this slightly shorter by using ack:
.PP
.Vb 6
\&      ack \-f \-\-perl lib        \e
\&      xargs perlimports        \e
\&      \-\-libs lib               \e
\&      \-\-no\-preserve\-unused     \e
\&      \-\-no\-preserve\-duplicates \e
\&      \-i
.Ve
.SH CAVEATS
.IX Header "CAVEATS"
There are lots of shenanigans that Perl modules can get up to. This code will
not find exports for all of those cases, but it should only attempt to rewrite
imports which it knows how to handle. Please file a bug report in all other
cases.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Perl::Critic::Policy::TooMuchCode::ProhibitUnusedImport,
Perl::Critic::Policy::TooMuchCode::ProhibitUnusedInclude and
Perl::Critic::Policy::TooMuchCode::ProhibitUnusedConstant
