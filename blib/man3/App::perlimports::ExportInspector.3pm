.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ExportInspector 3pm"
.TH ExportInspector 3pm 2025-10-30 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Inspect modules to see what they might export.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&    use strict;
\&    use warnings;
\&
\&    use App::perlimport::ExportInspector ();
\&
\&    my $ei = App::perlimport::ExportInspector\->new(
\&        module_name => \*(AqCarp\*(Aq,
\&    );
\&
\&    my $exports = $ei\->explicit_exports;
.Ve
.SH MOTIVATION
.IX Header "MOTIVATION"
Since we're (maybe) importing symbols as part of this process, we've sandboxed
it a little bit by not doing it in App::perlimports directly.
.SH METHODS
.IX Header "METHODS"
The following methods are available.
.SS implicit_exports
.IX Subsection "implicit_exports"
A HashRef with keys representing symbols which a module implicitly exports
(i.e.  via \f(CW\*(C`use Module::Name;\*(C'\fR. The values represent the import value which
you would need in order to explicitly import the symbol. Often these will be
the same, but there are exceptions. For example, a type library may export
\&\f(CW\*(C`is_ArrayRef\*(C'\fR, but you import it via \f(CW\*(C`use My::Type::Library qw( ArrayRef );\*(C'\fR.
.SS explicit_exports
.IX Subsection "explicit_exports"
A HashRef with keys representing symbols which a module explicitly exports
(i.e.  via \f(CW\*(C`use Module::Name qw( foo bar );\*(C'\fR. The values represent the import
value which you would need in order to explicitly import the symbol. Often
these will be the same, but there are exceptions. For example, a type library
may export \f(CW\*(C`is_ArrayRef\*(C'\fR, but you import it via \f(CW\*(C`use My::Type::Library qw(
ArrayRef );\*(C'\fR.
.PP
In cases where we cannot be certain about the explicit exports, you can try to
fall back to the implicit exports to get an idea of what this module can
export.
.SS evals_ok
.IX Subsection "evals_ok"
Returns true if either implicit or explicit exports can be built without
setting \f(CW$@\fR.
.SS implicit_export_names_match_values
.IX Subsection "implicit_export_names_match_values"
Returns true if the keys and values in \f(CW\*(C`implicit_exports\*(C'\fR match.
.SS explicit_export_names_match_values
.IX Subsection "explicit_export_names_match_values"
Returns true if the keys and values in \f(CW\*(C`explicit_exports\*(C'\fR match.
.SS success_counter
.IX Subsection "success_counter"
Returns an integer representing the number of times we were able to execute
eval statements for this package which did not pollute \f(CW$@\fR.
.SH CAVEATS
.IX Header "CAVEATS"
This may not work with modules using some creative way of managing symbol
exports.
